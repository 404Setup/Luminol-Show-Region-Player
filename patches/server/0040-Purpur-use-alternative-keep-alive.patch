From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrHua269 <novau233@163.com>
Date: Sat, 27 Jan 2024 13:25:30 +0000
Subject: [PATCH] Purpur use alternative keep alive


diff --git a/src/main/java/me/earthme/luminol/LuminolConfig.java b/src/main/java/me/earthme/luminol/LuminolConfig.java
index c79070eb6bb71d473fab758ae9d826276ae7eea6..ea9fe545a92ab555479fc518519be5d9f60efe11 100644
--- a/src/main/java/me/earthme/luminol/LuminolConfig.java
+++ b/src/main/java/me/earthme/luminol/LuminolConfig.java
@@ -63,6 +63,7 @@ public class LuminolConfig {
     public static int asyncPathProcessingMaxThreads = 0;
     public static int asyncPathProcessingKeepalive = 60;
     public static boolean enableAsyncMobSpawning = false;
+    public static boolean useAlternateKeepAlive = false;
 
     public static void init() throws IOException {
         PARENT_FOLDER.mkdir();
@@ -190,6 +191,7 @@ public class LuminolConfig {
             asyncPathProcessingMaxThreads = 0;
         enableAsyncMobSpawning = get("optimizations.enable_async_mob_spawning",enableAsyncMobSpawning);
         RegionizedWorldData.initMobSpawningExecutor();
+        useAlternateKeepAlive = get("optimizations.enable_alternative_keep_alive_handling",useAlternateKeepAlive,"Enabling this sends a keepalive packet once per second to a player, and only kicks for timeout if none of them were responded to in 30 seconds. Responding to any of them in any order will keep the player connected. AKA, it won't kick your players because one packet gets dropped somewhere along the lines(From purpur)");
     }
 
     public static <T> T get(String key,T def){
diff --git a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
index bdeb70fdcd2985c9ffd7cfb77f75d1bd1eb49a02..87922e561b4949e7b4ea124f3ecdcd94792825a3 100644
--- a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -51,6 +51,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
     private long keepAliveTime = Util.getMillis(); // Paper
     private boolean keepAlivePending;
     private long keepAliveChallenge;
+    private it.unimi.dsi.fastutil.longs.LongList keepAlives = new it.unimi.dsi.fastutil.longs.LongArrayList(); // Purpur
     private int latency;
     private volatile boolean suspendFlushingOnServerThread = false;
     public final java.util.Map<java.util.UUID, net.kyori.adventure.resource.ResourcePackCallback> packCallbacks = new java.util.concurrent.ConcurrentHashMap<>(); // Paper - adventure resource pack callbacks
@@ -103,6 +104,16 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
 
     @Override
     public void handleKeepAlive(ServerboundKeepAlivePacket packet) {
+        // Purpur start
+        if (me.earthme.luminol.LuminolConfig.useAlternateKeepAlive) {
+            long id = packet.getId();
+            if (keepAlives.size() > 0 && keepAlives.contains(id)) {
+                int ping = (int) (Util.getMillis() - id);
+                this.latency = (this.latency * 3 + ping) / 4;
+                keepAlives.clear(); // we got a valid response, lets roll with it and forget the rest
+            }
+        } else
+        // Purpur end
         //PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // CraftBukkit // Paper - This shouldn't be on the main thread
         if (this.keepAlivePending && packet.getId() == this.keepAliveChallenge) {
             int i = (int) (Util.getMillis() - this.keepAliveTime);
@@ -221,6 +232,21 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
         long currentTime = Util.getMillis();
         long elapsedTime = currentTime - this.keepAliveTime;
 
+        // Purpur start
+        if (me.earthme.luminol.LuminolConfig.useAlternateKeepAlive) {
+            if (elapsedTime >= 1000L) { // 1 second
+                if (!processedDisconnect && keepAlives.size() * 1000L >= KEEPALIVE_LIMIT) {
+                    LOGGER.warn("{} was kicked due to keepalive timeout!", this.player.getScoreboardName());
+                    disconnect(ServerCommonPacketListenerImpl.TIMEOUT_DISCONNECTION_MESSAGE, org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT);
+                } else {
+                    keepAliveTime = currentTime; // hijack this field for 1 second intervals
+                    keepAlives.add(currentTime); // currentTime is ID
+                    send(new ClientboundKeepAlivePacket(currentTime));
+                }
+            }
+        } else
+        // Purpur end
+
         if (this.keepAlivePending) {
             if (!this.processedDisconnect && elapsedTime >= KEEPALIVE_LIMIT) { // check keepalive limit, don't fire if already disconnected
                 ServerGamePacketListenerImpl.LOGGER.warn("{} was kicked due to keepalive timeout!", this.player.getScoreboardName()); // more info
